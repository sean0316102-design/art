<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>響應式 p5.js 藝術遊戲</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #050510; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none; /* 防止手機瀏覽器預設的縮放與滑動 */
        }
        /* 響應式 UI 層 */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between; /* 分散對齊 */
            color: #00fff2;
            pointer-events: none;
            /* 使用 clamp 讓字體隨螢幕大小自動縮放 */
            font-size: clamp(14px, 4vw, 20px);
            text-shadow: 0 0 8px rgba(0,255,242,0.6);
            z-index: 10;
        }
        .stat-box { background: rgba(0,0,0,0.3); padding: 5px 15px; border-radius: 20px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="stat-box">得分: <span id="score">0</span></div>
        <div class="stat-box">剩餘時間: <span id="timer">30</span>s</div>
    </div>

    <script>
        let particles = [];
        let score = 0;
        let timer = 30;
        let gameState = "PLAY";
        let interactDist; // 動態感應距離

        function setup() {
            // 建立填滿視窗的畫布
            createCanvas(windowWidth, windowHeight);
            setResponsiveValues();
            initParticles();
            setInterval(countDown, 1000);
        }

        function draw() {
            background(5, 5, 20, 60);

            if (gameState === "PLAY") {
                // p5.js 會自動將觸控座標映射到 mouseX, mouseY
                handleParticles();
                drawUI();
            } else {
                showGameOver();
            }
        }

        // --- 核心響應式邏輯 ---
        function windowResized() {
            // 當視窗大小改變時，重新調整畫布
            resizeCanvas(windowWidth, windowHeight);
            setResponsiveValues();
        }

        function setResponsiveValues() {
            // 根據螢幕寬度決定粒子感應距離 (手機小一點，電腦大一點)
            interactDist = map(width, 375, 1920, 80, 150);
            
            // 確保粒子不會超出新視窗邊界
            particles.forEach(p => p.clampPos());
        }

        function initParticles() {
            // 根據螢幕面積決定粒子數量 (避免手機太卡)
            let count = floor(map(width * height, 100000, 2000000, 30, 100));
            particles = [];
            for (let i = 0; i < count; i++) particles.push(new Particle());
        }

        function handleParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].display();
                
                let d = dist(mouseX, mouseY, particles[i].pos.x, particles[i].pos.y);
                if (d < 35) {
                    particles.splice(i, 1);
                    score += 10;
                    document.getElementById('score').innerText = score;
                    particles.push(new Particle());
                }
            }
            drawConnections();
        }

        class Particle {
            constructor() {
                this.pos = createVector(random(width), random(height));
                this.vel = p5.Vector.random2D().mult(random(1, 2.5));
                this.size = random(3, 6);
            }

            update() {
                this.pos.add(this.vel);
                if (this.pos.x < 0 || this.pos.x > width) this.vel.x *= -1;
                if (this.pos.y < 0 || this.pos.y > height) this.vel.y *= -1;
            }

            clampPos() {
                this.pos.x = constrain(this.pos.x, 0, width);
                this.pos.y = constrain(this.pos.y, 0, height);
            }

            display() {
                noStroke();
                fill(0, 255, 242, 180);
                circle(this.pos.x, this.pos.y, this.size);
            }
        }

        function drawConnections() {
            strokeWeight(1);
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    let d = dist(particles[i].pos.x, particles[i].pos.y, particles[j].pos.x, particles[j].pos.y);
                    if (d < interactDist) {
                        stroke(100, 255, 218, map(d, 0, interactDist, 150, 0));
                        line(particles[i].pos.x, particles[i].pos.y, particles[j].pos.x, particles[j].pos.y);
                    }
                }
            }
        }

        function countDown() {
            if (timer > 0 && gameState === "PLAY") {
                timer--;
                document.getElementById('timer').innerText = timer;
            } else if (timer <= 0) {
                gameState = "GAMEOVER";
            }
        }

        function showGameOver() {
            fill(255);
            textAlign(CENTER, CENTER);
            textSize(width > 600 ? 40 : 24);
            text("TIME'S UP!", width / 2, height / 2 - 20);
            textSize(width > 600 ? 20 : 16);
            text(`Score: ${score}\nTap to Restart`, width / 2, height / 2 + 40);
        }

        function mousePressed() {
            if (gameState === "GAMEOVER") {
                score = 0;
                timer = 30;
                initParticles();
                gameState = "PLAY";
            }
        }

        // 禁止手機長按彈出選單
        document.oncontextmenu = () => false;
    </script>
</body>
</html>
